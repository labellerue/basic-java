package f_oop2;

public class InheritanceBasic {
	public static void main(String[] args) {
		
		/*
		1. 상속(~은 ~이다.)
			- 기존의 클래스를 재사용하여 새로운 클래스를 작성한다
			- 적은 양의 코드로 새로운 클래스를 작성할 수 있다.
			- 새로 작성하고자 하는 클래스의 뒤에 상속받고자 하는 클래스의 이름을 키워드'extends'와 함께 써주기만 하면 된다.
			
				class Child extends Parent{
				}
			- 상속해주는 클래스를 '조상클래스', 상속받는 클래스를 '자손클래스'라 한다.
			  : 조상클래스 - 부모클래스, 상위클래스, 기반클래스
			  : 자손클래스 - 자식클래스, 상위클래스, 파생된클래스
			  
			- 멤버만 상속된다.
			- 자손클래스의 멤버 개수는 조상클래스보다 항상 같거나 많다.
			
		2. 포함(~은 ~을 포함하고 있다.)
			- 상속 이외의 클래스를 재사용하는 방법이다.
			- 한 클래스의 멤버변수로 다른 클래스를 선언하는 방법이다.
			
		3. 단일상속
			- 자바에서는 단일상속(두개이상은 불가능)만 가능하다.
				class TVCR extends TV,VCR{	//불가
				}
			- Tv와 VCR에 동일명의 메서드가 있다면 어떤것을 상속받을지 알 수 없다.
			  VCR의 메서드명을 바꾼다면 구분은 가능하겠지만 이전에 VCR을 사용하던 모든 부분에 대해 수정해 주어야 한다.
			- 클래스간의 관계가 좀 더 명확해지므로 코드를 더욱 신뢰할 수 있다.
			
		4. Object클래스(모든클래스의 조상)
			- 모든 클래스 상속 계층도의 제일 위에 위치하는 조상 클래스이다.
			- 다른클래스로부터 상속 받지 않는 클래스들은 자동적으로 Object클래스를 상속받는다.
			  class Tv{
			  }
			  컴파일되면
			  class Tv extends Object{
			  }
			
		5. 오버라이딩(override)
			- 조상클래스로부터 상속받는 메서드를 재정의 하는 것.
			- 오버라이딩이 성립하기 위한 조건(선언부가 일치하면 된다.)
			  : 자손크래스에서 오버라이딩하는 메서드는 조상클래스의 메서드와 이름이 같아야 한다.
			     매개변수의 개수와 타입이 같아야 한다.
			     리턴타입도 같아야 한다.
			  : 조상클래스의 메서드를 자손클래스에서 오버라이딩할 때 접근제어자를 조상클래스의 메서드보다 좁은 범위로 변경할 수 없다.
			     예외는 조상클래스의 메서드보다 많이 선언할 수 없다.
			     인스턴스메서드를 클래스메서드로 또는 그 반대로 할 수 없다.
			     
		6. super.
			- 조상클래스의 멤버와 자손클래스의 멤버가 중복 정의되어 있어 서로 구분해야 하는 경우 사용
			- 조상멤버와 자신의 멤버를 구별하는데 사용된다는 점을 제외하고는 
			  this.과 근본적으로 같다.
			- static메서드에 사용할 수 없다.
			
		7. super()
			- 조상클래스의 생성자 호출
			- this()와 마찬가지로 super()역시 생성자 호출이다.
			- this()는 같은 클래스의 다른 생성자 호출
			  super()는 조상클래스의 생성자 호출
			- 생성자의 첫 줄에는 조상클래스의 생성자를 호출해야 한다. 
			  자손클래스의 멤버가 조상클래스의 멤버를 사용할 수 있음으로 조상의 멤버들을 먼저 초기화 한다.
			- 자식 생성자 내에 자동으로 부모생성자super() 생성
			- super()와 this()는 가장 윗줄에 있어야 하기 때문에 함께 사용할 수 없다.
		
		8. 제어자
			- 클래스, 변수 또는 메서드의 선언부에 사용된다.
			- 접근제어자와 그외 제어자로 나누어진다.
			  : 접근제어자 => private, default, protected, public
			  : 그외제어자 => static, final, abstract, native...
			- 접근제어자는 일반적으로 가장 앞에 써준다.  *리턴타입은 무조건 메서드명 바로 앞에
			- static(클래스의, 공통적인)
			  : 멤버변수, 메서드, 초기화블럭
			  : static 멤버변수
			     모든 인스턴스에서 공통적을 사용.
			     인스턴스를 생성하지 않고 사용할 수 있다.
			     클래스가 메모리에 로드될 때 같이 생성된다.
			  : static 메서드
			    인스턴스를 생성하지 않고 호출이 가능한 메서드
			    클래스메서드 내에서는 인스턴스 멤버들을 호출할 수 없다.
			- final(마지막의 변경할 수 없는)
			  : 변수에서 사용시 상수가 된다.
			  : 메서드 사용시 오버라이딩할 수 없다.
			  : 클래스에 사용시 다른 클래스의 조상이 될 수 없습니다.
			- abstract(추상의 미완성의)
			  : 메서드 사용시 구현부가 존재하지 않는 메서드
			    void method();
			  : 클래스에서 사용시 추상메서드가 존재하는 클래스임을 알려준다.
			  
		9. 접근제어자
			- private : 같은 클래스 내에서 접근이 가능하다.
			- default : 같은 패키지 내에서만 접근이 가능하다.
			- protected : 같은 패키지 + 다른 패키지의 자손클래스에서 접근가능
			- public : 접근제한이 없다.
			- 클래스에는 public과 default만 사용 가능하다.
			- 메서드 및 멤버변수에는 전부 사용 가능하다.
			
		10. 캡슐화
			- 접근제어자를 사용하는 이유
			  : 외부로부터 데이터를 보호하기 위해서
			  : 외부에는 불필요한, 내부적으로만 사용되는 부분을 감추기 위해
			  
		11. 생성자의 접근 제어자
			- 인스턴스의 생성을 제한할 수 있다.
			- 생성자의 접근제어자를 private으로 지정
			  : 외부에서 생성자에 접근할 수 없으므로 인스턴스의 생성을 제한할 수 있다.
			  : 다른 클래스의 조상이 될 수 없다.
			  : 상속할 수 없는 클래스임을 알려주는 final을 추가하여 상속할 수 없는 클래스임을 알리는 것이 좋다.
			  
		12. 다형성(polymorphism)
			- 여러가지 형태를 가질 수 있는 능력
			- 한 타입의 참조변수로 여러 타입의 객체를 참조할 수 있다.
			- 부모타입의 참조변수로 자손타입의 인스턴스를 참조할 수 있다.
			- 자손타입의 참조변수로 부모타입의 인스턴스를 참조할 수 없다.
			
		13. 참조변수의 형변화
			- 서로 상속관계에 있는 클래스에서만 형변환이 가능하다.
			- 자손 => 부모 (up-casting) : 형변환 생략이 가능
			   부모 => 자손 (down-casitng) : 형변환 생략이 불가능
			
		14. instanceof 연산자
			- 참조변수가 참조하고 있는 인스턴스의 실제 타입을 알아보기 위해 사용
			- 연산결과가 true라면 참조변수가 검사한 타입으로 형변환이 가능하다.
			- 클래스메서드는 클래스변수처럼 참조변수의 타입에 영향을 받는다.
			   참조변수의 타입에 영향을 받지 않는 것은 인스턴스 메서드 뿐이다.
			
		15. 매개변수의 다형성
			- 참조변수의 다형적인 특징을 메서드의 매개변수에 활용할 수 있다.
			
		16. 여러객체배열 Vector
			- 배열: Product[] p = new Product[]{new Notebook, new Tv2, new Dyson};
			
			- Vector
			  : 배열을 사용할 경우 전체 크기를 한번 정하면 확장할 수 없다.
			     이를 Vector클래스를 이용하여 해결할 수 있다.
			  : 동적으로 크기가 관리되는 객체배열 이라고 생각하면 된다. (아직 배운 바로는 기본형은 넣을 수 없다.)
			  
			  Vector() : 10개의 객체를 저장할 수 있는 Vector인스턴스를 생성한다.
			  add()    : 객체를 추가한다. (여러 오버로딩이 존재함)
			  remove() : 객체를 삭제한다. (여러 오버로딩이 존재함)
			  isEmpty(): Vector가 비어있는지 확인한다.
			  Object get(int index) : 해당번째 객체를 반환해준다. (Object인 이유는 어떤 것도 다 받아주려고)
			  int size() : 저장된 객체의 개수를 반환한다.
			  
		17. 추상크래스(abstract class)
			- 미완성된 클래스: 미완성된 메서드를 포함하고 있다는 의미
			abstract class 클래스명{
			}

			- 추상메서드
			  : 메서드는 선언부와 구현부로 이루어져 있다.
			  : 선언부만 만들어지고 구현부는 작성되지 않은 메서드를 추상메서드라 한다.
			  abstract void method();
			  
			- 추상클래스를 상속받는 자손 클래스는 오버라이딩을 통해 조상인 클래스의 추상메서드를 구현하여 추상클래스가 아닐 수 있다.
			
		18. 인터페이스(interface) *1.7기준
			- 일종의 추상클래스이지만 추상메서드, 상수만 사용할 수 있다.
			- 인터페이스의 작성
			  interface 인터페이스명{
			  	public static final 변수타입 상수명 = 값; (초기화까지)
			  	public abstract 반환타입 메서드명(매개변수);
			  }
			  : 모든 멤버변수(상수) public static final이어야 한다. 생략 가능
			  : 모든 메서드는 public abstract이어야 한다. 생략 가능
			  
			- 인터페이스의 상속
			  : 인터페이스는 인터페이스만 상속 받을 수 있다.
			  : 클래스와 달리 다중상속이 가능하다.
			  : 구현부 없이 선언부만 있으니 모두 똑같이 생겨서 다중상속이 가능	
			  : 인터페이스는 클래스와 달리 Object클래스와 같은 최고 조상이 없다.
			  
			- 인터페이스의 구현(추상클래스와 비슷하다.)
			  : 자체로는 인스턴스를 생성할 수 없다. 생성자가 없기 때문에 인스턴스화 불가능
			  : 자신이 정의된 추상메서드의 몸통을 만들어 주는 클래스를 작성한다.
			  : 클래스의 확장(extends), 인터페이스의 구현(implements)    클래스가 인터페이스를 구현하려면 implements, 인터페이스가 인터페이스를 상속받으려면 extends
			  : 인터페이스의 일부 메서드만 구현했다면 그 클래스는 추상클래스가 된다.
			  : ~able(~할 수 있는) ex. Movable			(예전 트렌드)
			    IMemberService 사람을 관리하는 인터페이스		(요즘 트렌드)
			    => IMemberServiceImpl
			  : 인터페이스 타입의 참조변수로 그를 구현한 구현체의 인스턴스를 참조할 수 있다.
			- 인터페이스의 장점
			  : 개발시간을 단축할 수 있다.
			  : 표준화가 가능하다.
			  : 서로 관계가 없는 클래스들에게 관계를 맺어줄 수 있다.
			  : 독립적인 프로그래밍이 가능하다.
			  7-26 예제 해보세요
			  
			- 인터페이스의 이해
			  : 클래스를 제공하는 쪽(provider)와 클래스를 사용하는 쪽(user)
			  : 직접적인 관계를 간접적 관계로 변경해줄 수 있다.(캡슐화 관련)
			  	A - I - B 중간에 인터페이스 존재
			  	
			- 1.8에서는 인터페이스의 메서드에 구현부가 존재
			- 단 static과 default 메서드만 가능
			  
		19. 내부클래스(inner class)
			- 내부클래스란?
			  : 클래스내에 선언된 클래스이다.
			  : 서로 쉽게 접근할 수 있고 외부에서 볼 때 불필요한 클래스를 감춤으로 복잡성을 줄일 수 있다.
			  
			- 인스턴스클래스(instance class)
			  : 외부클래스의 인스턴스멤버들과 관련된 작업을 수행한다.
			- 스태틱 클래스(static class)
			  : 외부클래스의 클래스멤버들과 관련된 작업을 수행한다.
			- 지역 클래스(local class)
			  : 외부클래스의 메서드나 초기화블럭 안에 선언되며, 선언영역 내에서만 사용될 수 있다.
			- 익명클래스(anonymous class)
			  : 클래스의 선언과 객체의 생성을 동시에 진행하는 이름없는 클래스(일회용)
			  
		
		 */
		
	}
}
